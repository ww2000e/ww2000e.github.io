<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bash后台运行不提示进程号]]></title>
    <url>%2F2019%2F07%2F02%2Fbash%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%B8%8D%E6%8F%90%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[linux的shell里面后台运行程序总会提示进程号和进程完成的提示 类似这样： 1234$ls &amp;[1] 119788$ [1] + 119788 done 如果不需要提示，可以这样解决： 1$(ls &amp;) 加一对括号即可,让它在子shell里面执行]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>bash</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux只能搜索到部分无线网问题解决]]></title>
    <url>%2F2019%2F06%2F13%2Flinuxwifi%2F</url>
    <content type="text"><![CDATA[​ 笔记本上ubuntu更新为最新的系统后，突然只能搜到一部分网络，家里的无线网搜索不出来，查了很多资料都没解决，直到有天突然win10也出现同样状况，查阅资料发现，win10可以修改无线网卡的country region值，一般1~13，和无线路由器的信道对上即可，原来是我无线路由自动设置的信道比较偏门，既然两个系统都搜索不到，还是改无线路由比较方便，登陆后，修改无线路由的信道为10，ubuntu，win10都可以正常连上了。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim插件安装使用整理记录]]></title>
    <url>%2F2019%2F03%2F27%2Fvim-plugin-note%2F</url>
    <content type="text"><![CDATA[自己用到的vim插件安装，使用方法记录。基于vim8.x。插件管理使用vundle。 vundle ctrl-p vim-vue vim-flake8 vim-autoformat vim-go powerline solarized配色 vundle插件管理工具 安装先获取插件1git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 然后.vimrc中加入以下配置, 按照模板修改下,里面写的几个plugin我都删了 12345678910111213141516171819202122232425262728293031323334353637383940414243set nocompatible &quot; be iMproved, requiredfiletype off &quot; required&quot; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()&quot; alternatively, pass a path where Vundle should install plugins&quot;call vundle#begin(&apos;~/some/path/here&apos;)&quot; let Vundle manage Vundle, requiredPlugin &apos;VundleVim/Vundle.vim&apos;&quot; The following are examples of different formats supported.&quot; Keep Plugin commands between vundle#begin/end.&quot; plugin on GitHub repoPlugin &apos;tpope/vim-fugitive&apos;&quot; plugin from http://vim-scripts.org/vim/scripts.html&quot; Plugin &apos;L9&apos;&quot; Git plugin not hosted on GitHubPlugin &apos;git://git.wincent.com/command-t.git&apos;&quot; git repos on your local machine (i.e. when working on your own plugin)Plugin &apos;file:///home/gmarik/path/to/plugin&apos;&quot; The sparkup vim script is in a subdirectory of this repo called vim.&quot; Pass the path to set the runtimepath properly.Plugin &apos;rstacruz/sparkup&apos;, &#123;&apos;rtp&apos;: &apos;vim/&apos;&#125;&quot; Install L9 and avoid a Naming conflict if you&apos;ve already installed a&quot; different version somewhere else.&quot; Plugin &apos;ascenator/L9&apos;, &#123;&apos;name&apos;: &apos;newL9&apos;&#125;&quot; All of your Plugins must be added before the following linecall vundle#end() &quot; requiredfiletype plugin indent on &quot; required&quot; To ignore plugin indent changes, instead use:&quot;filetype plugin on&quot;&quot; Brief help&quot; :PluginList - lists configured plugins&quot; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache&quot; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal&quot;&quot; see :h vundle for more details or wiki for FAQ&quot; Put your non-Plugin stuff after this line 配置完成后命令行执行1vim +PluginInstall +qall 或者vim里面命令行执行1:PluginInstall 使用查看帮助1:h vundle 常见命令12345:PluginInstall:PluginUpdate:PluginSearch:PluginList:PluginClean ctrl-p模糊搜索文件插件 安装打开.vimrc加入下面内容后，执行:PluginInstall1Plugin &apos;ctrlpvim/ctrlp.vim&apos; 使用 快捷键 功能 ctrl + p 开启文件搜索 F5 刷新当前目录内容 ctrl + f/b 切换显示模式 ctrl + d 只搜索文件名 ctrl + r 正则查找模式 ctrl + j/k 搜索结果中移动光标 ctrl + t 新标签页打开 ctrl + v/x 垂直分割打开 / 水平分割打开 ctrl + n/p 上下翻阅上次搜索历史 ctrl + y 在选中文件的父级目录创建新文件 ctrl + z 标记选择多个文件 ctrl + o 选择打开方式 vim-vuevue代码高亮 安装.vimrc中加入1Plugin &apos;posva/vim-vue&apos; 使用打开.vue即可 vim-flake8检查python是否按pep8规范 安装123Plugin &apos;nvie/vim-flake8&apos;pip3 install flake8 使用按F7开启 vim-autoformatvim自动格式化代码插件 安装.vimrc中增加1Plugin &apos;Chiel92/vim-autoformat&apos; 增加快捷键配置1noremap &lt;F3&gt; :Autoformat&lt;CR&gt; 增加对python代码的支持,安装autopep81pip install --upgrade autopep8 使用按F3开启 vim-gogolang的高亮，代码检查插件。 安装很简单，主要是代理设置花了点功夫。 安装通过vundle安装，vimrc中设置1Plugin &apos;fatih/vim-go&apos; 然后执行1vim +PluginInstall +qall 没问题的话，go的高亮已经支持了，接下来开始安装一些工具,因为需要使用go get，所以得设置代理,一开始我直接export https_proxy或者git 配置代理，然后进入vim开始安装vim-go工具，总是go get失败，后来发现一个解决方法：1# export https_proxy=http://127.0.0.1:8118; vim 然后在vim命令行模式中输入1:GoInstallBinaries 即可全部安装完成。这样安装同样可用于其他go get命令，将export https_proxy写在go get前面。 使用vim命令行中查看说明1:h vim-go 快捷键 功能 ctrl + ] 跳转到定义处 ctrl + t 从ctrl + ] 跳转的地方跳转回去 参考 https://github.com/fatih/vim-go-tutorial#quick-setup powerline安装.vimrc中加入 1Plugin &apos;powerline/powerline&apos;, &#123;&apos;rtp&apos;: &apos;powerline/bindings/vim/&apos;&#125; 另外要下载powerline-fonts字体，执行install.sh脚本安装 使用.vimrc中加入配置 1set laststatus=2 solarized配色安装.vimrc中加入1Plugin &apos;altercation/vim-colors-solarized&apos; 使用.vimrc中加入配置123let g:solarized_termcolors=256set background=light和dark二选一colorscheme solarized]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7下编译vim8]]></title>
    <url>%2F2019%2F03%2F23%2Fcentos7%E4%B8%8B%E7%BC%96%E8%AF%91vim8-1%2F</url>
    <content type="text"><![CDATA[记录下编译vim8碰到的坑 下载vim源码下载最新的vim8源码1git clone https://github.com/vim/vim.git 编译并支持python3先运行configure,记得带上–enable-fail-if-missing ，否则不会去报错，因为没开这个项，我始终找不到python3支持编译不进来原因，也没有任何报错，最后加上后发现是python的config文件夹找不到。1./configure --with-features=huge --enable-multibyte --enable-python3interp=yes --prefix=/usr/local/vim --with-python3-command=python3.4 --enable-fail-if-missing --with-python3-config-dir=/usr/lib64/python3.4/config-3.4m 然后make，make install即可12make -j8make install 最后替换掉老的vim1ln -s /usr/local/vim/bin/vim /usr/bin/vim]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>linux</tag>
        <tag>vim8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下prezto和tmux配置]]></title>
    <url>%2F2019%2F03%2F11%2Fprezto-tmux-config%2F</url>
    <content type="text"><![CDATA[记录下prezto和tmux的安装配置，tmux基于2.8版本 prezto安装12345678$zsh$git clone --recursive https://github.com/sorin-ionescu/prezto.git &quot;$&#123;ZDOTDIR:-$HOME&#125;/.zprezto&quot;$setopt EXTENDED_GLOBfor rcfile in &quot;$&#123;ZDOTDIR:-$HOME&#125;&quot;/.zprezto/runcoms/^README.md(.N); do ln -s &quot;$rcfile&quot; &quot;$&#123;ZDOTDIR:-$HOME&#125;/.$&#123;rcfile:t&#125;&quot;done 配置12345678910111213141516171819202122232425262728# 新增tmux模块$sed -i &quot;s/ &apos;prompt&apos;/ &apos;prompt&apos; \\\\\n &apos;tmux&apos;\n/g&quot; /root/.zpreztorc# 开机启动tmux，remote为远程登陆时才启动tmux$sed -i &quot;s/# zstyle &apos;:prezto:module:tmux:auto-start&apos; remote &apos;yes&apos;/zstyle &apos;:prezto:module:tmux:auto-start&apos; remote &apos;yes&apos;/g&quot; /root/.zpreztorc# 命令行使用vi模式 $sed -i &quot;s/zstyle &apos;:prezto:module:editor&apos; key-bindings &apos;emacs&apos;/zstyle &apos;:prezto:module:editor&apos; key-bindings &apos;vi&apos;/g&quot; /root/.zpreztorc# prezto下ctrl+r生效$vim ~/.zpreztorczstyle &apos;:prezto:load&apos; pmodule \ &apos;environment&apos; \ &apos;terminal&apos; \ &apos;editor&apos; \ &apos;history&apos; \ &apos;directory&apos; \ &apos;spectrum&apos; \ &apos;utility&apos; \ &apos;completion&apos; \ &apos;prompt&apos; \ &apos;history-substring-search&apos; \ #增加history-substring-search &apos;tmux&apos;# .zshrc中新增一行$vim ~/.zshrcbindkey &quot;^R&quot; history-incremental-search-backward tmux配置prezto中设置过启动tmux，这里只需要配置下就可以了。 12# 安装xclip支持复制到系统剪贴板apt install xclip 打开~/.tmux.conf写入以下内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#set -g prefix C-b # Some people like set leader key to Crtl_a, but I don&apos;t like it!#unbind C-b# Split windowsbind \ split-window -hbind - split-window -vset-window-option -g mode-keys vi set -g status-keys vibind-key -T copy-mode-vi &apos;v&apos; send-keys -X begin-selection bind-key -T copy-mode-vi y send-keys -X copy-selectionbind-key -T copy-mode-vi r send-keys -X rectangle-togglebind -T copy-mode-vi y send-keys -X copy-pipe-and-cancel &apos;xclip -in -selection clipboard&apos; set -g base-index 1 # window index from 1, not zeroset -s escape-time 0bind r source-file ~/.tmux.conf \; display &quot;Reloaded!&quot;bind-key / command-prompt &quot;split-window -h &apos;exec man %%&apos;&quot;set-option -g allow-rename off # prevent system from renaming our windowset -g default-terminal &quot;screen-256color&quot;set -g status-justify leftset -g status-interval 1set -g status-position topset -g status-bg colour234set -g status-fg colour137set -g status-attr dimset -g status-left &apos;&apos;# status右边显示当前时间set -g status-right &apos;#[fg=colour233,bg=colour241,bold] %d/%m #[fg=colour233,bg=colour245,bold] %H:%M:%S &apos;set -g status-right-length 50set -g status-left-length 20# 设置windows菜单颜色 Prefix+wsetw -g clock-mode-colour colour135setw -g mode-attr boldsetw -g mode-fg colour15setw -g mode-bg colour238# pane borderset -g pane-border-bg colour235set -g pane-border-fg colour238set -g pane-active-border-bg colour236set -g pane-active-border-fg colour15# 设置status面板当前windows颜色setw -g window-status-current-fg colour81setw -g window-status-current-bg colour238setw -g window-status-current-attr boldsetw -g window-status-current-format &apos; #I#[fg=colour250]:#[fg=colour255]#W#[fg=colour50]#F &apos;# 设置status非活跃windows颜色setw -g window-status-fg colour138setw -g window-status-bg colour235setw -g window-status-attr nonesetw -g window-status-format &apos; #I#[fg=colour237]:#[fg=colour250]#W#[fg=colour244]#F &apos;setw -g window-status-bell-attr boldsetw -g window-status-bell-fg colour255setw -g window-status-bell-bg colour1# 设置message字体颜色set -g message-attr bold#set -g message-fg colour232set -g message-fg colour15set -g message-bg colour236# 解决xshell下tmux的分屏resize问题bind -r ^k resizep -U 10 # upward (prefix Ctrl+k)bind -r ^j resizep -D 10 # downward (prefix Ctrl+j)bind -r ^h resizep -L 10 # to the left (prefix Ctrl+h)bind -r ^l resizep -R 10 # to the right (prefix Ctrl+l)]]></content>
      <categories>
        <category>linux命令行</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10下docker搭建linux开发环境]]></title>
    <url>%2F2019%2F01%2F10%2Fwin10-docker-dev-env%2F</url>
    <content type="text"><![CDATA[以前用windows开发需要linux环境，可能会安装虚机，自己再去安装系统，现在有了容器这种技术后，搭建方便多了。 效果图 工具选择： docker for windows (windows下的docker，和vmware冲突) mosh (基于udp的ssh，速度快些) zsh (比较喜欢的终端) prezto (zsh的插件，相比oh-my-zsh,更喜欢这个) tmux (分屏工具) centos7.6 搭建过程总结成dockerfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354FROM centos:7.6.1810# local timeRUN ln -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime# change charsetRUN sed -i &apos;s/override_install_langs=en_US.utf8/# override_install_langs=en_US.utf8/g&apos; /etc/yum.confRUN yum -y -q reinstall glibc-common# install packageRUN yum -y install epel-releaseRUN yum -y install vim python34 python34-pip openssh-server git zsh tmux iproute mosh# install and configure preztoRUN zsh -c &apos;git clone --recursive https://github.com/sorin-ionescu/prezto.git &quot;$&#123;ZDOTDIR:-$HOME&#125;/.zprezto&quot;&apos;RUN zsh -c &apos;source &quot;$&#123;ZDOTDIR:-$HOME&#125;/.zprezto/init.zsh&quot;; \ setopt EXTENDED_GLOB; \ for rcfile in &quot;$&#123;ZDOTDIR:-$HOME&#125;&quot;/.zprezto/runcoms/^README.md(.N); do; \ ln -s &quot;$rcfile&quot; &quot;$&#123;ZDOTDIR:-$HOME&#125;/.$&#123;rcfile:t&#125;&quot;; \ done&apos;RUN sed -i &quot;s/ &apos;prompt&apos;/ &apos;prompt&apos; \\\\\n &apos;tmux&apos;\n/g&quot; /root/.zpreztorcRUN sed -i &quot;s/# zstyle &apos;:prezto:module:tmux:auto-start&apos; remote &apos;yes&apos;/zstyle &apos;:prezto:module:tmux:auto-start&apos; remote &apos;yes&apos;/g&quot; /root/.zpreztorcRUN sed -i &quot;zstyle &apos;:prezto:module:editor&apos; key-bindings &apos;emacs&apos;/zstyle &apos;:prezto:module:editor&apos; key-bindings &apos;vi&apos;/g&quot; /root/.zpreztorcRUN chsh -s /usr/bin/zsh# configure sshdRUN ssh-keygen -q -t rsa -b 2048 -f /etc/ssh/ssh_host_rsa_key -N &apos;&apos;RUN ssh-keygen -q -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N &apos;&apos;RUN ssh-keygen -t dsa -f /etc/ssh/ssh_host_ed25519_key -N &apos;&apos;RUN echo &quot;root:登陆&quot;密码&quot; | chpasswd# configure localeRUN echo &apos;export LANG=&quot;en_US.UTF-8&quot;&apos; &gt;&gt; /root/.zshrcRUN echo &apos;export LC_ALL=&quot;en_US.UTF-8&quot;&apos; &gt;&gt; /root/.zshrc# configure tmux vimCOPY .vimrc /root/COPY .tmux.conf /root/ENTRYPOINT [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;] 简单的vimrc1234set history=200set tabstop=4set expandtabsyntax on 附带比较喜欢tmux配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#set -g prefix C-b # Some people like set leader key to Crtl_a, but I don&apos;t like it!#unbind C-b# Split windowsbind \ split-window -hbind - split-window -v#set-option -g default-shell zshsetw -g mode-keys vi#set-option -g default-command &quot;reattach-to-user-namespace -l zsh&quot;# start selecting text typing &apos;v&apos; key (once you are in copy mode)bind-key -t vi-copy v begin-selection# copy selected text to the system&apos;s clipboard#bind-key -t vi-copy y copy-pipe &quot;reattach-to-user-namespace pbcopy&quot;set -g base-index 1 # window index from 1, not zeroset -s escape-time 0bind r source-file ~/.tmux.conf \; display &quot;Reloaded!&quot;bind-key / command-prompt &quot;split-window -h &apos;exec man %%&apos;&quot;set-option -g allow-rename off # prevent system from renaming our windowset -g default-terminal &quot;screen-256color&quot;set -g status-justify leftset -g status-interval 1set -g status-position topset -g status-bg colour234set -g status-fg colour137set -g status-attr dimset -g status-left &apos;&apos;# status右边显示当前时间set -g status-right &apos;#[fg=colour233,bg=colour241,bold] %d/%m #[fg=colour233,bg=colour245,bold] %H:%M:%S &apos;set -g status-right-length 50set -g status-left-length 20# 设置windows菜单颜色 Prefix+wsetw -g clock-mode-colour colour135setw -g mode-attr boldsetw -g mode-fg colour15setw -g mode-bg colour238# pane borderset -g pane-border-bg colour235set -g pane-border-fg colour238set -g pane-active-border-bg colour236set -g pane-active-border-fg colour15# 设置status面板当前windows颜色setw -g window-status-current-fg colour81setw -g window-status-current-bg colour238setw -g window-status-current-attr boldsetw -g window-status-current-format &apos; #I#[fg=colour250]:#[fg=colour255]#W#[fg=colour50]#F &apos;# 设置status非活跃windows颜色setw -g window-status-fg colour138setw -g window-status-bg colour235setw -g window-status-attr nonesetw -g window-status-format &apos; #I#[fg=colour237]:#[fg=colour250]#W#[fg=colour244]#F &apos;setw -g window-status-bell-attr boldsetw -g window-status-bell-fg colour255setw -g window-status-bell-bg colour1# 设置message字体颜色set -g message-attr bold#set -g message-fg colour232set -g message-fg colour15set -g message-bg colour236]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>win10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux终端程序收集]]></title>
    <url>%2F2018%2F12%2F28%2Flinux-console%2F</url>
    <content type="text"><![CDATA[天气预报1curl http://wttr.in/ asciiquarium字符界面的水族馆 KMSCON能作为 Linux 内核内置终端的一个完整替代,支持中文]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>console</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker学习笔记]]></title>
    <url>%2F2018%2F12%2F05%2Fdocker-note%2F</url>
    <content type="text"><![CDATA[记录docker常用命令 docker镜像导出镜像1docker save [img id] &gt; [img name].tar 保存镜像的历史 导入镜像1docker load &lt; [img name].tar docker容器导出容器1docker export [container id] &gt; [container id].tar 不含镜像历史 导入容器1docker import [container id].tar]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux桌面日常使用问题记录]]></title>
    <url>%2F2018%2F11%2F17%2Flinux-desktop-note%2F</url>
    <content type="text"><![CDATA[记录各个发行版桌面日常使用问题 zsh的prezto插件开启ctrl+r功能1234567891011121314151617181920$vim ~/.zpreztorczstyle &apos;:prezto:load&apos; pmodule \ &apos;environment&apos; \ &apos;terminal&apos; \ &apos;editor&apos; \ &apos;history&apos; \ &apos;directory&apos; \ &apos;spectrum&apos; \ &apos;utility&apos; \ &apos;completion&apos; \ &apos;prompt&apos; \ &apos;history-substring-search&apos; \ #增加history-substring-search &apos;tmux&apos;# .zshrc中新增一行$vim ~/.zshrcbindkey &quot;^R&quot; history-incremental-search-backward ubuntu的sublime支持中文输入法按照网址内步骤安装 https://github.com/lyfeyaj/sublime-text-imfix 确保sublime安装在/opt/sublime_text目录下确保/usr/bin/subl可用如果没有生成菜单项,自行复制src/sublime_text.desktop至/usr/share/applications/目录下 gnome3给home目录的默认文件夹切换成英文 参考：http://dbua.iteye.com/blog/943945 home目录下中文在shell里面用起来很麻烦，网上找了修改方法123$export LANG=en_US$xdg-user-dirs-gtk-update$export LANG=zh_CN.UTF-8 ubuntu18.04,18.10搜狗输入法 参考：https://www.jianshu.com/p/c936a8a2180e 轻量浏览器试了好多，最后选择:Falkon]]></content>
      <categories>
        <category>linux桌面</category>
      </categories>
      <tags>
        <tag>linux桌面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go语言笔记]]></title>
    <url>%2F2018%2F11%2F12%2Fgolang-note%2F</url>
    <content type="text"><![CDATA[go语言学习笔记 数组，切片，映射数组 数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型 数组元素初始化为0 快速创建并初始化 1array := [5]int&#123;1,2,3,4,5&#125; “…” 替代初始化: 1array := [...]int&#123;1,2,3,4,5&#125; 按索引修改数组: 1array[2] = 35 整型指针初始化索引: 1array := [5]*int&#123;0: new(int), 1: new(int)&#125; ，为索引0赋值*array[0] = 10 同样类型数组可以直接赋值 12array2 := [5]string&#123;&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;&#125;array1 = array2 不同类型数组不可以赋值 指针数组赋值给另一个 123456var array1 [3]*stringarray2 := [3]*string&#123;new(string), new(string), new(string)&#125;*array2[0] = &quot;Red&quot;*array2[1] = &quot;Blue&quot;*array2[2] = &quot;Green&quot;array1 = array2 多维数组 12345678// 声明一个二维整型数组，两个维度分别存储 4 个元素和 2 个元素var array [4][2]int// 使用数组字面量来声明并初始化一个二维整型数组array := [4][2]int&#123;&#123;10, 11&#125;, &#123;20, 21&#125;, &#123;30, 31&#125;, &#123;40, 41&#125;&#125;// 声明并初始化外层数组中索引为 1 个和 3 的元素array := [4][2]int&#123;1: &#123;20, 21&#125;, 3: &#123;40, 41&#125;&#125;// 声明并初始化外层数组和内层数组的单个元素array := [4][2]int&#123;1: &#123;0: 20&#125;, 3: &#123;1: 41&#125;&#125; 函数间传递数组 函数间传递开销很大。每次函数调用都会分配数组大小的内存。 使用指针在函数间传递大数组，只需要分配指针内存就可以。12345678// 分配一个需要 8 MB 的数组var array [1e6]int// 将数组的地址传递给函数 foofoo(&amp;array)// 函数 foo 接受一个指向 100 万个整型值的数组的指针func foo(array *[1e6]int) &#123;...&#125; 切片 片是一种数据结构,这种数据结构便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处 切片是很小对象，对底层抽象。切片包括指针、长度、容量。 一种创建方法是用make 1234// 字符串切片,其长度和容量都是 5 个元素slice := make([]string, 5)// 整型切片，其长度为 3 个元素，容量为 5 个元素slice := make([]int, 3, 5) 通过切片字面量来声明 123456// 创建字符串切片// 其长度和容量都是 5 个元素slice := []string&#123;&quot;Red&quot;, &quot;Blue&quot;, &quot;Green&quot;, &quot;Yellow&quot;, &quot;Pink&quot;&#125;// 创建一个整型切片// 其长度和容量都是 3 个元素slice := []int&#123;10, 20, 30&#125; 使用索引声明切片 123// 创建字符串切片// 使用空字符串初始化第 100 个元素slice := []string&#123;99: &quot;&quot;&#125; 声明数组和声明切片的不同 1234// 创建有 3 个元素的整型数组array := [3]int&#123;10, 20, 30&#125;// 创建长度和容量都是 3 的整型切片slice := []int&#123;10, 20, 30&#125; nil和空切片 12// 创建 nil 整型切片。 指针nil，长度0，容量0var slice []int 声明空切片。地址指针，长度0，容量0 1234// 使用 make 创建空的整型切片slice := make([]int, 0)// 使用切片字面量创建空的整型切片slice := []int&#123;&#125; 使用切片创建切片 1234567// 创建一个整型切片// 其长度和容量都是 5 个元素slice := []int&#123;10, 20, 30, 40, 50&#125;// 创建一个新切片// 其长度为 2 个元素，容量为 4 个元素newSlice := slice[1:3] 计算长度和容量 123n = slice[i: j]长度: j - i容量: k - i 3个索引的切片 123// slice[i:j:k]// 长度: j – i// 容量: k – i 切片增长 123456789// 创建一个整型切片// 其长度和容量都是 5 个元素slice := []int&#123;10, 20, 30, 40, 50&#125;// 创建一个新切片// 其长度为 2 个元素，容量为 4 个元素newSlice := slice[1:3]// 使用原有的容量来分配一个新元素// 将新元素赋值为 60newSlice = append(newSlice, 60) 迭代切片 12345slice := []int&#123;10, 20, 30, 40&#125;// 迭代每一个元素，并显示其值for index, value := range slice &#123; fmt.Printf(&quot;Index: %d Value: %d\n&quot;, index, value)&#125; range返回两个值,每个元素的副本，而不是返回该元素 要想获取每个元素地址，可以使用切片变量和索引值 _可以替代索引值 内置函数len返回切片长度。cap返回切片容量。 函数间可以直接传递切片，切片尺寸很小，复制成本低。 映射 映射是一种数据结构，存储一系列无序键值对。 映射可以快速检索数据 映射是一个无序集合 可以使用make创建映射 12345// 创建一个映射，键的类型是 string，值的类型是 intdict := make(map[string]int)// 创建一个映射，键和值的类型都是 string// 使用两个键值对初始化映射dict := map[string]string&#123;&quot;Red&quot;: &quot;#da1337&quot;, &quot;Orange&quot;: &quot;#e95a22&quot;&#125; 使用映射 1234// 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码colors := map[string]string&#123;&#125;// 将 Red 的代码加入到映射colors[&quot;Red&quot;] = &quot;#da1337&quot; 从映射获取值并判断键是否存在 123456// 获取键 Blue 对应的值value, exists := colors[&quot;Blue&quot;]// 这个键存在吗？if exists &#123; fmt.Println(value)&#125; 从映射获取值，并通过该值判断键是否存在 123456// 获取键 Blue 对应的值value := colors[&quot;Blue&quot;]// 这个键存在吗？if value != &quot;&quot; &#123; fmt.Println(value)&#125; range迭代映射 1234567891011// 创建一个映射，存储颜色以及颜色对应的十六进制代码colors := map[string]string&#123; &quot;AliceBlue&quot;: &quot;#f0f8ff&quot;, &quot;Coral&quot;: &quot;#ff7F50&quot;, &quot;DarkGray&quot;: &quot;#a9a9a9&quot;, &quot;ForestGreen&quot;: &quot;#228b22&quot;,&#125;// 显示映射里的所有颜色for key, value := range colors &#123; fmt.Printf(&quot;Key: %s Value: %s\n&quot;, key, value)&#125; 从映射中删除一项 1delete(aaa, bbb) // 只能用在映射存储的值都是非零值的情况 函数间传递映射 函数间传递映射并不会制造出映射副本。传递后修改都是对本映射修改 类型系统用户定义类型 go是静态类型编程语言。需要指明每个值类型。 值有个信息：内存大小，类型 关键字type struct 1234567// user 在程序里定义一个用户类型type user struct &#123; name string email string ext int privileged bool&#125; 使用结构类型声明变量，初始化为0 1var bill user 使用结构字面量来声明一个结构类型的变量 123456lisa := user&#123; name: &quot;Lisa&quot;, email: &quot;lisa@email.com&quot;, ext: 123, privileged: true,&#125; 使用结构字面量创建结构类型的值 1234567user&#123; name: &quot;Lisa&quot;, email: &quot;lisa@email.com&quot;, ext: 123, privileged: true,&#125;//结构字面量可以对结构类型采用两种形式 基于已有类型声明一个新类型 1type Duration int64 给不同类型的变量赋值会产生编译错误 方法 方法能给用户定义的类型添加新的行为 关键字 func 和函数名之间的参数被称作接收者 12345678910// user 在程序里定义一个用户类型type user struct &#123; name string email string&#125;// notify 使用值接收者实现了一个方法func (u user) notify() &#123; fmt.Printf(&quot;Sending User Email To %s&lt;%s&gt;\n&quot;,u.name,u.email)&#125; 使用值接受者声明一个方法 12345func (u user) notify() &#123;&#125;bill := user&#123;&quot;Bill&quot;, &quot;bill@email.com&quot;&#125;bill.notify() 类型本质内置类型 内置类型是由语言提供一组类型。如数值，字符串，布尔。 引用类型 切片，映射，通道，接口，函数类型 以上类型创建变量称作：标头值 结构类型 结构类型可以描述一组数据值。 接口 多态是指代码可以根据类型的具体实现采取不同行为的能力 接口是用来定义行为的类型 嵌入类型公开或未公开标识符 参考： 《go语言实战》]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++学习笔记]]></title>
    <url>%2F2018%2F11%2F04%2Fcpp-note%2F</url>
    <content type="text"><![CDATA[学习c++记录 函数复习函数知识定义函数函数原型和函数调用 原型描述了函数到编译器的接口。 函数参数和按值传递函数和数组函数如何使用指针来处理数组12arr[i] == *(ar + i) &amp;arr[i] == ar + i 将数组作为参数意味着什么 传递变量时，函数使用变量拷贝。传递数组时，函数将使用原来数组。 const可以保护数组数组区间的函数 STL方法使用“超尾”指定区间，对于数组，标识数组结尾参数将是指向最后一个元素后面的指针。 const和指针1234567891011int a = 1;const int * p = a; //p指向const int , *p不能修改int *p = &amp;a; // *p可以修改值const int * pt = p; //*pt 不可以修改值const int a = 1;const int * p = &amp;a // 可以将const变量赋值给指向const的指针。const int a = 1;int * p = &amp;a // 错误,不可以将const地址赋值给常规指针。 如果数据类型本身不是指针，可以将const数据或非const数据的地址赋值给指向const的指针，但只能将非const数据的地址赋值给非const指针 1234int a = 3;cont int * p = &amp;a; //指针指向const int。p可以修改指向，不能修改*p值int * const f = &amp;a; //const指针指向int。*f可以修改,f不能修改指向const int * const f = &amp;a; //const指针指向const int。*f不可以修改,f不能修改指向 函数和二维数组123int fun(int (*ar2)[4]), int size); // 指向4个int组成的数组指针int ar2[][4] //可读性更强int *ar2[4] //没有括号表示4个指向int的指针组成的数组 1234567iint ar2[r][c]ar2[r][c] == *(*ar2 + r) + c) //运算符*两次标示数组ar2 // 指向第一行ｃ个元素的指针ar2 + r // 第r行c个元素的指针*(ar2 + r) //相当于ar2[r],指向r行指针*(ar2 + r) + c // 相当于ar2[r] + c，指向r行第c个*(*(ar2 + r) + c) // 相当于ar2[r][c],r行c列的值 对象和类类介绍访问控制 通过关键字private和public。 隐藏数据是OOP主要目标之一，数据项通常放在私有部分。 类的默认访问属性是private。 类的成员函数 通过作用域解析运算符(::)来标识函数所属的类。 类方法可以访问类的private组件。 限定名：somecls::func()，非限定名：func() 类声明中的函数是内联函数,在类声明外声明内联使用inline 类构造函数和析构函数 构造函数没有返回值和声明类型 构造函数可以通过重载创建多个 构造函数不要用类成员变量当参数 未提供构造函数则会生成隐式构造函数 编译器决定何时调用析构函数 this指针 this指针指向用来调用成员函数的对象 *this表示整个调用对象 对象数组类作用域 直接成员运算符(.)，间接成员运算符(-&gt;)，作用域解析运算符(::) 作用域常量,声明两种方式，enum、static c++11作用域枚举enum class, enum struct 使用类运算符重载 重载限制：重载后运算符至少一个操作数是用户定义的类型，运算符不能违反原来的句法规则，不能创建新的运算符，不能重载一些特定运算符，（=,(),[],-&gt;)只能通过成员函数进行重载。 友元 关键字friend 友元有三种：友元函数，友元类，友元成员函数 类继承派生一个类 class newc : public basec{ } basec是共有基类，newc是公有派生 派生类存储了基类的数据成员，派生类对象可以使用基类方法 派生类不能直接访问基类的私有成员，必须通过基类方法进行访问 派生类构造函数要点：派生类构造函数应用；派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；派生类构造函数应初始化派生类新增的数据成员 创建派生类时，程序首先调用基类构造函数，然后调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数用于初始化新增的数据成员。派生类构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构，然后在调用基类析构函数。使用派生类 派生类和基类之间的特殊关系:派生类可以使用基类的非私有方法。基类指针、引用可以在不进行显示类型转换的情况下指向派生类对象。 基类指针或引用只能用于调用基类方法。 不可以将基类对象和地址赋给派生类引用和指针。is-a关系 3种继承方式：公有继承，保护继承，私有继承。多态公有继承 派生类中重新定义基类方法。使用虚方法。使用虚析构函数可以确保正确的析构函数序列被调用。 静态联编和动态联编 动态联编与通过指针和引用调用方法相关。c++不允许将一种类型的地址赋值给另一种类型的指针，也不允许一种类型的引用指向另一种类型。 将派生类引用或指针转换为基类引用或指针被称为向上强制转换，这使公有继承不需要进行显示类型转换。 将基类指针或引用转换为派生类指针或引用,称为向下强制转换。 虚函数:c++规定了虚函数的行为,实现方法留给编译器作者。通常实现方法：每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。这种称为虚函数表。虚函数表中存储了为类对象进行声明的虚函数地址。程序调用虚函数：在存储对象中查看vtbl地址，然后转向相应的函数地址表，如果使用类声明中定义的第一个虚函数，程序将使用数组中第一个函数地址。并执行具有该地址的函数。 虚函数内存，执行速度成本：每个对象都将增大，增加存储地址空间。 每个类，编译器都创建一个虚函数地址表。 每个函数都需要额外操作，表中查找地址。 虚函数事项： 基类方法声明中使用关键字virtual可使该方法在基类以及所有的派生类中是虚的。 如果使用指向对象的引用或者指针来调用虚函数，程序将使用对象类型定义的方法，而不使用为引用或指针类型定义的方法,这称为动态联编或晚期联编。如果定义的类被用于基类，则应将那些派生类中重新定义的类方法声明为虚的。 虚函数注意事项：构造函数不能是虚函数，派生类调用派生类构造函数，派生类不继承基类的构造函数，构造函数声明为虚函数没有意义。析构函数应当是虚函数，除非类不做基类。 友元： 友元不能使虚函数，因为友元不是类成员，而是成员才能有虚函数。可以通过让友元函数使用虚成员函数来解决。 如果派生类没有重新定义函数，将使用该函数的基类版本。 重新定义将隐藏方法。重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将隐藏所有的同名基类方法。两条规则：如果重载定义继承的方法，应确保与原来的原型完全相同，如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针，这种特性被称为返回类型协变，因为允许返回类型随类类型变化而变化。 如果基类声明被重载了，则应在派生类中重新定义所有基类版本。 访问控制：protected 类外只能用公有类成员来访问protected部分中的类成员。 private和protected之间区别只有在基类派生中的类中才会表现出来。 派生类成员可以直接访问基类的保护成员,但不能直接访问基类的私有成员。 抽象基类 abc理念 继承和动态内存分配 当基类和派生类都采用动态内存分配时，派生类的析构函数、复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。这要求三种不同的方式来满足。析构函数：自动完成；构造函数：通过初始化成员列表中调用基类的复制构造函数完成，自动调用基类的默认构造函数。赋值运算符:通过使用作用域解析运算符显示的调用基类的赋值运算符来完成。 函数 能否继承 成员还是友元 默认能否生成 能否为虚函数 是否可以有返回类型 构造函数 否 成员 能 否 否 析构函数 否 成员 能 能 否 = 否 成员 能 能 能 &amp; 能 任意 能 能 能 转换函数 能 成员 否 能 否 （） 能 成员 否 能 能 [] 能 成员 否 能 能 -&gt; 能 成员 否 能 能 op= 能 任意 否 能 能 new 能 静态成员 否 否 void * delete 能 静态成员 否 否 void * 其他运算符 能 任意 否 能 能 其他成员 能 成员 否 能 能 友元 否 友元 否 否 能 代码重用包含对象成员的类私有继承 has-a关系途径。私有继承。基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用他们。 使用私有继承，在派生类的方法中使用基类方法。 使用作用域解析运算符可以访问基类的方法。 类名显式的限定函数名不适合于友元函数。因为友元不属于类。可以通过显示的转换为基类来调用正确的函数。 包含还是私有继承: 保护继承:保护继承是私有继承的变体。使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。和私有私有继承一样，基类的接口在派生类中也是可用的，但是在继承层次结构之外是不可用的。 using重新定义访问权限：使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。 多重继承 必须使用关键字public来限定每一个基类。否则编译器将认为是私有派生。 虚基类使得多个类派生出的对象只继承一个基类对象。 类模板 继承和包含并不总是能够满足重用代码需要。 友元友元类 友元声明可以位于公有，私有或保护部分，所在位置无关紧要。 友元成员函数。 其他友元关系。 共同的友元。 嵌套类 访问权限 参考： 《c++ primer plus》第六版]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2F2018%2F10%2F23%2Fpython%E6%A8%A1%E5%9D%97%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考: https://realpython.com/ 查看当前全局变量，局部变量12345678910111213# &quot;globals()&quot; returns a dict# with all global variables# in the current scope:&gt;&gt;&gt; globals()&#123;...&#125;# &quot;locals()&quot; does the same# but for all local variables# in the current scope:&gt;&gt;&gt; locals()&#123;...&#125; 合并字典12345678910111213141516# How to merge two dictionaries# in Python 3.5+&gt;&gt;&gt; x = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2&#125;&gt;&gt;&gt; y = &#123;&apos;b&apos;: 3, &apos;c&apos;: 4&#125;&gt;&gt;&gt; z = &#123;**x, **y&#125;&gt;&gt;&gt; z&#123;&apos;c&apos;: 4, &apos;a&apos;: 1, &apos;b&apos;: 3&#125;# In Python 2.x you could# use this:&gt;&gt;&gt; z = dict(x, **y)&gt;&gt;&gt; z&#123;&apos;a&apos;: 1, &apos;c&apos;: 4, &apos;b&apos;: 3&#125; 字典排序12345678910111213# How to sort a Python dict by value# (== get a representation sorted by value)&gt;&gt;&gt; xs = &#123;&apos;a&apos;: 4, &apos;b&apos;: 3, &apos;c&apos;: 2, &apos;d&apos;: 1&#125;&gt;&gt;&gt; sorted(xs.items(), key=lambda x: x[1])[(&apos;d&apos;, 1), (&apos;c&apos;, 2), (&apos;b&apos;, 3), (&apos;a&apos;, 4)]# Or:&gt;&gt;&gt; import operator&gt;&gt;&gt; sorted(xs.items(), key=operator.itemgetter(1))[(&apos;d&apos;, 1), (&apos;c&apos;, 2), (&apos;b&apos;, 3), (&apos;a&apos;, 4)] 格式化json打印123456789101112131415161718# The standard string repr for dicts is hard to read:&gt;&gt;&gt; my_mapping = &#123;&apos;a&apos;: 23, &apos;b&apos;: 42, &apos;c&apos;: 0xc0ffee&#125;&gt;&gt;&gt; my_mapping&#123;&apos;b&apos;: 42, &apos;c&apos;: 12648430. &apos;a&apos;: 23&#125; # 😞# The &quot;json&quot; module can do a much better job:&gt;&gt;&gt; import json&gt;&gt;&gt; print(json.dumps(my_mapping, indent=4, sort_keys=True))&#123; &quot;a&quot;: 23, &quot;b&quot;: 42, &quot;c&quot;: 12648430&#125;# Note this only works with dicts containing# primitive types (check out the &quot;pprint&quot; module):&gt;&gt;&gt; json.dumps(&#123;all: &apos;yup&apos;&#125;)TypeError: keys must be a string 传递参数方式1234567891011121314# Why Python Is Great:# Function argument unpackingdef myfunc(x, y, z): print(x, y, z)tuple_vec = (1, 0, 1)dict_vec = &#123;&apos;x&apos;: 1, &apos;y&apos;: 0, &apos;z&apos;: 1&#125;&gt;&gt;&gt; myfunc(*tuple_vec)1, 0, 1&gt;&gt;&gt; myfunc(**dict_vec)1, 0, 1 timeit测量代码执行速度123456789101112131415161718# The &quot;timeit&quot; module lets you measure the execution# time of small bits of Python code&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.timeit(&apos;&quot;-&quot;.join(str(n) for n in range(100))&apos;, number=10000)0.3412662749997253&gt;&gt;&gt; timeit.timeit(&apos;&quot;-&quot;.join([str(n) for n in range(100)])&apos;, number=10000)0.2996307989997149&gt;&gt;&gt; timeit.timeit(&apos;&quot;-&quot;.join(map(str, range(100)))&apos;, number=10000)0.24581470699922647 is和”==”比较is 判断两个变量指向对象是否一样== 判断两个变量值是否一样12345678910111213141516171819202122# &quot;is&quot; vs &quot;==&quot;&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; a == bTrue&gt;&gt;&gt; c = list(a)&gt;&gt;&gt; a == cTrue&gt;&gt;&gt; a is cFalse# • &quot;is&quot; expressions evaluate to True if two # variables point to the same object# • &quot;==&quot; evaluates to True if the objects # referred to by the variables are equal 关于python函数1234567891011121314# Functions are first-class citizens in Python:# They can be passed as arguments to other functions,# returned as values from other functions, and# assigned to variables and stored in data structures.&gt;&gt;&gt; def myfunc(a, b):... return a + b...&gt;&gt;&gt; funcs = [myfunc]&gt;&gt;&gt; funcs[0]&lt;function myfunc at 0x107012230&gt;&gt;&gt;&gt; funcs[0](2, 3)5 模拟switch/case123456789101112131415161718192021222324252627282930313233343536# Because Python has first-class functions they can# be used to emulate switch/case statementsdef dispatch_if(operator, x, y): if operator == &apos;add&apos;: return x + y elif operator == &apos;sub&apos;: return x - y elif operator == &apos;mul&apos;: return x * y elif operator == &apos;div&apos;: return x / y else: return Nonedef dispatch_dict(operator, x, y): return &#123; &apos;add&apos;: lambda: x + y, &apos;sub&apos;: lambda: x - y, &apos;mul&apos;: lambda: x * y, &apos;div&apos;: lambda: x / y, &#125;.get(operator, lambda: None)()&gt;&gt;&gt; dispatch_if(&apos;mul&apos;, 2, 8)16&gt;&gt;&gt; dispatch_dict(&apos;mul&apos;, 2, 8)16&gt;&gt;&gt; dispatch_if(&apos;unknown&apos;, 2, 8)None&gt;&gt;&gt; dispatch_dict(&apos;unknown&apos;, 2, 8)None list操作123456789101112131415161718# Python&apos;s list comprehensions are awesome.vals = [expression for value in collection if condition]# This is equivalent to:vals = []for value in collection: if condition: vals.append(expression)# Example:&gt;&gt;&gt; even_squares = [x * x for x in range(10) if not x % 2]&gt;&gt;&gt; even_squares[0, 4, 16, 36, 64] 1234567891011121314151617181920212223242526# Python&apos;s list slice syntax can be used without indices# for a few fun and useful things:# You can clear all elements from a list:&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]&gt;&gt;&gt; del lst[:]&gt;&gt;&gt; lst[]# You can replace all elements of a list# without creating a new list object:&gt;&gt;&gt; a = lst&gt;&gt;&gt; lst[:] = [7, 8, 9]&gt;&gt;&gt; lst[7, 8, 9]&gt;&gt;&gt; a[7, 8, 9]&gt;&gt;&gt; a is lstTrue# You can also create a (shallow) copy of a list:&gt;&gt;&gt; b = lst[:]&gt;&gt;&gt; b[7, 8, 9]&gt;&gt;&gt; b is lstFalse collections统计字数1234567891011# collections.Counter lets you find the most common# elements in an iterable:&gt;&gt;&gt; import collections&gt;&gt;&gt; c = collections.Counter(&apos;helloworld&apos;)&gt;&gt;&gt; cCounter(&#123;&apos;l&apos;: 3, &apos;o&apos;: 2, &apos;e&apos;: 1, &apos;d&apos;: 1, &apos;h&apos;: 1, &apos;r&apos;: 1, &apos;w&apos;: 1&#125;)&gt;&gt;&gt; c.most_common(3)[(&apos;l&apos;, 3), (&apos;o&apos;, 2), (&apos;e&apos;, 1)] itertools排列12345678910111213141516171819202122232425262728&gt;&gt;&gt; import itertools&gt;&gt;&gt; for p in itertools.permutations(&apos;ABCD&apos;):... print(p)(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;)(&apos;A&apos;, &apos;B&apos;, &apos;D&apos;, &apos;C&apos;)(&apos;A&apos;, &apos;C&apos;, &apos;B&apos;, &apos;D&apos;)(&apos;A&apos;, &apos;C&apos;, &apos;D&apos;, &apos;B&apos;)(&apos;A&apos;, &apos;D&apos;, &apos;B&apos;, &apos;C&apos;)(&apos;A&apos;, &apos;D&apos;, &apos;C&apos;, &apos;B&apos;)(&apos;B&apos;, &apos;A&apos;, &apos;C&apos;, &apos;D&apos;)(&apos;B&apos;, &apos;A&apos;, &apos;D&apos;, &apos;C&apos;)(&apos;B&apos;, &apos;C&apos;, &apos;A&apos;, &apos;D&apos;)(&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;A&apos;)(&apos;B&apos;, &apos;D&apos;, &apos;A&apos;, &apos;C&apos;)(&apos;B&apos;, &apos;D&apos;, &apos;C&apos;, &apos;A&apos;)(&apos;C&apos;, &apos;A&apos;, &apos;B&apos;, &apos;D&apos;)(&apos;C&apos;, &apos;A&apos;, &apos;D&apos;, &apos;B&apos;)(&apos;C&apos;, &apos;B&apos;, &apos;A&apos;, &apos;D&apos;)(&apos;C&apos;, &apos;B&apos;, &apos;D&apos;, &apos;A&apos;)(&apos;C&apos;, &apos;D&apos;, &apos;A&apos;, &apos;B&apos;)(&apos;C&apos;, &apos;D&apos;, &apos;B&apos;, &apos;A&apos;)(&apos;D&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;)(&apos;D&apos;, &apos;A&apos;, &apos;C&apos;, &apos;B&apos;)(&apos;D&apos;, &apos;B&apos;, &apos;A&apos;, &apos;C&apos;)(&apos;D&apos;, &apos;B&apos;, &apos;C&apos;, &apos;A&apos;)(&apos;D&apos;, &apos;C&apos;, &apos;A&apos;, &apos;B&apos;)(&apos;D&apos;, &apos;C&apos;, &apos;B&apos;, &apos;A&apos;) disdis模块包括用于反编译 Python 字节码将其拆解为更易于阅读的形式的函数。123456789101112131415161718# You can use Python&apos;s built-in &quot;dis&quot;# module to disassemble functions and# inspect their CPython VM bytecode:&gt;&gt;&gt; def greet(name):... return &apos;Hello, &apos; + name + &apos;!&apos;&gt;&gt;&gt; greet(&apos;Dan&apos;)&apos;Hello, Dan!&apos;&gt;&gt;&gt; import dis&gt;&gt;&gt; dis.dis(greet)2 0 LOAD_CONST 1 (&apos;Hello, &apos;) 2 LOAD_FAST 0 (name) 4 BINARY_ADD 6 LOAD_CONST 2 (&apos;!&apos;) 8 BINARY_ADD 10 RETURN_VALUE datetimestrptimestrptime 是将字符串转换为 datetime，其实这个方法的全称是 “string parse time”，叫做字符串解析成时间，重点在解析（parse），理解这个三个单词，你就不会忘记了。 1234&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; datetime.strptime(&apos;2018-10-15 20:59:29&apos;, &apos;%Y-%m-%d %H:%M:%S&apos;)datetime.datetime(2018, 10, 15, 20, 59, 29)strftime strftime 是将 datetime 转换为字符串，全称是 “string format time”，翻译过来就是将字符串的形式来格式化时间，重点在格式化（format），使之以一种可读的字符串形式返回。 12&gt;&gt;&gt; datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)&apos;2018-11-02 16:16:45&apos; iso8601时间转换转换时间字符串到datetime12import datetimedatetime.datetime.strptime(&quot;2018-12-14T08:58:50Z&quot;, &quot;%Y-%m-%dT%H:%M:%SZ&quot;) 转换datetime到时间字符串1dstr = dt.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) utc转换为本地时间 参考: https://stackoverflow.com/questions/4563272/convert-a-python-utc-datetime-to-a-local-datetime-using-only-python-standard-lib 123456# in Python 3.3+:from datetime import timezonedef utc_to_local(utc_dt): return utc_dt.replace(tzinfo=timezone.utc).astimezone(tz=None) 123456789# python2/3import calendarfrom datetime import datetime, timedeltadef utc_to_local(utc_dt): # get integer timestamp to avoid precision lost timestamp = calendar.timegm(utc_dt.timetuple()) local_dt = datetime.fromtimestamp(timestamp) assert utc_dt.resolution &gt;= timedelta(microseconds=1) return local_dt.replace(microsecond=utc_dt.microsecond) 12345678# using pytz. python2/3import pytzlocal_tz = pytz.timezone(&apos;Europe/Moscow&apos;) # use your local timezone name heredef utc_to_local(utc_dt): local_dt = utc_dt.replace(tzinfo=pytz.utc).astimezone(local_tz) return local_tz.normalize(local_dt) # .normalize might be unnecessary]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>python</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node_exporter关于disk监控项含义]]></title>
    <url>%2F2018%2F10%2F11%2Fnode-exporter%E5%85%B3%E4%BA%8Edisk%E7%9B%91%E6%8E%A7%E9%A1%B9%E5%90%AB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[花了点时间弄清楚node_exporter中disk取值方式。类似于iostat之类工具，都是从/proc/diskstats中取值。对应关系如下: metrics /proc/diskstats对应项 解释 node_disk_reads_completed_total Field 1 – # of reads completed 读操作的次数 node_disk_reads_merged_total Field 2 – # of reads merged )合并读操作的次数。如果两个读操作读取相邻的数据块时，可以被合并成一个，以提高效率。合并的操作通常是I/O scheduler（也叫elevator）负责的 node_disk_read_bytes_total Field 3 – # of sectors read 读取的扇区数量。node_exporter中直接乘512换算成bytes node_disk_read_time_seconds_total Field 4 – # of milliseconds spent reading 读操作消耗的时间（以毫秒为单位）。每个读操作从__make_request()开始计时，到end_that_request_last()为止，包括了在队列中等待的时间。node_exporter中换算成秒 node_disk_writes_completed_total Field 5 – # of writes completed 写操作的次数 node_disk_writes_merged_total Field 6 – # of writes merged 合并写操作的次数 node_disk_written_bytes_total Field 7 – # of sectors written 写入的扇区数量。node_exporter中直接乘512换算成bytes node_disk_write_time_seconds_total Field 8 – # of milliseconds spent writing 写操作消耗的时间（以毫秒为单位）。node_exporter中换算成秒 node_disk_io_now Field 9 – # of I/Os currently in progress 当前未完成的I/O数量。在I/O请求进入队列时该值加1，在I/O结束时该值减1。注意：是I/O请求进入队列时，而不是提交给硬盘设备时。 node_disk_io_time_seconds_total Field 10 – # of milliseconds spent doing I/Os 该设备用于处理I/O的自然时间(wall-clock time)。请注意io_ticks与rd_ticks(字段#4)和wr_ticks(字段#8)的区别，rd_ticks和wr_ticks是把每一个I/O所消耗的时间累加在一起，因为硬盘设备通常可以并行处理多个I/O，所以rd_ticks和wr_ticks往往会比自然时间大。而io_ticks表示该设备有I/O（即非空闲）的时间，不考虑I/O有多少，只考虑有没有。在实际计算时，字段#9(in_flight)不为零的时候io_ticks保持计时，字段#9(in_flight)为零的时候io_ticks停止计时。node_exporter中换算成秒 node_disk_io_time_weighted_seconds_total Field 11 – weighted # of milliseconds spent doing I/Os (time_in_queue)对字段#10(io_ticks)的加权值。字段#10(io_ticks)是自然时间，不考虑当前有几个I/O，而time_in_queue是用当前的I/O数量（即字段#9 in-flight）乘以自然时间。虽然该字段的名称是time_in_queue，但并不真的只是在队列中的时间，其中还包含了硬盘处理I/O的时间。iostat在计算avgqu-sz时会用到这个字段。node_exporter中换算成秒 参考： https://www.kernel.org/doc/Documentation/iostats.txthttp://linuxperf.com/?p=156]]></content>
      <categories>
        <category>prometheus监控</category>
      </categories>
      <tags>
        <tag>node_exporter</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux shell笔记]]></title>
    <url>%2F2018%2F10%2F08%2Flinux-shell%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[常用命令查看正在使用什么shell12ps -p $$echo $0 查看所有已安装shell1cat /etc/shells grep12345678910grep forest f.txt #文件查找grep forest f.txt cpf.txt #多文件查找grep &apos;log&apos; /home/admin -r -n #目录下查找所有符合关键字的文件cat f.txt | grep -i shopbase grep &apos;shopbase&apos; /home/admin -r -n --include *.&#123;vm,java&#125; #指定文件后缀grep &apos;shopbase&apos; /home/admin -r -n --exclude *.&#123;vm,java&#125; #反匹配seq 10 | grep 5 -A 3 #上匹配seq 10 | grep 5 -B 3 #下匹配seq 10 | grep 5 -C 3 #上下匹配，平时用这个就妥了cat f.txt | grep -c &apos;SHOPBASE&apos; awk 基础 123456awk &apos;&#123;print $4,$6&#125;&apos; f.txtawk &apos;&#123;print NR,$0&#125;&apos; f.txt cpf.txt awk &apos;&#123;print FNR,$0&#125;&apos; f.txt cpf.txtawk &apos;&#123;print FNR,FILENAME,$0&#125;&apos; f.txt cpf.txtawk &apos;&#123;print FILENAME,&quot;NR=&quot;NR,&quot;FNR=&quot;FNR,&quot;$&quot;NF&quot;=&quot;$NF&#125;&apos; f.txt cpf.txtecho 1:2:3:4 | awk -F: &apos;&#123;print $1,$2,$3,$4&#125;&apos; 匹配 1234awk &apos;/ldb/ &#123;print&#125;&apos; f.txt #匹配ldbawk &apos;!/ldb/ &#123;print&#125;&apos; f.txt #不匹配ldbawk &apos;/ldb/ &amp;&amp; /LISTEN/ &#123;print&#125;&apos; f.txt #匹配ldb和LISTENawk &apos;$5 ~ /ldb/ &#123;print&#125;&apos; f.txt #第五列匹配ldb 内建变量NR:NR表示从awk开始执行后，按照记录分隔符读取的数据次数，默认的记录分隔符为换行符，因此默认的就是读取的数据行数，NR可以理解为Number of Record的缩写。 FNR:在awk处理多个输入文件的时候，在处理完第一个文件后，NR并不会从1开始，而是继续累加，因此就出现了FNR，每当处理一个新文件的时候，FNR就从1开始计数，FNR可以理解为File Number of Record。 NF: NF表示目前的记录被分割的字段的数目，NF可以理解为Number of Field tr待补充 tee待补充 find12345678910111213sudo -u admin find /home/admin /tmp /usr -name \*.log(多个目录去找)find . -iname \*.txt(大小写都匹配)find . -type d(当前目录下的所有子目录)find /usr -type l(当前目录下所有的符号链接)find /usr -type l -name &quot;z*&quot; -ls(符号链接的详细信息 eg:inode,目录)find /home/admin -size +250000k(超过250000k的文件，当然+改成-就是小于了)find /home/admin f -perm 777 -exec ls -l &#123;&#125; \; (按照权限查询文件)find /home/admin -atime -1 1天内访问过的文件find /home/admin -ctime -1 1天内状态改变过的文件 find /home/admin -mtime -1 1天内修改过的文件find /home/admin -amin -1 1分钟内访问过的文件find /home/admin -cmin -1 1分钟内状态改变过的文件 find /home/admin -mmin -1 1分钟内修改过的文件 其他问题记录kill掉bash中while循环123456// 当写了 while [[ 1 ]]; do somecmd; sleep 60; done &amp;后如何kill掉此循环// 执行命令找出关系$ps fjx2226 9411 9411 8383 ? -1 S 1000 0:00 \_ /bin/bash9411 17674 9411 8383 ? -1 Sl 1000 0:00 \_ somecmd// 9411就是执行while进程 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD centos的yum报错$releasever别人装好的centos一个源都没有，配置源后又和redhat-release冲突执行，给redhat-release删了后，执行yum命令的时候提示http://mirrors.aliyun.com/centos/%24releasever/addons/x86_64/repodata/repomd.xml应该是环境变量$releasever没了,yum –releasever=7 install centos-release后依然无效。不知道这个变量存在哪，网上找了个设置方法。。 解决方法:1$echo 7 &gt; /etc/yum/vars/releasever 其他 查看正在使用什么shell 12ps -p $$echo $0 查看所有已安装shell 1cat /etc/shells 修改shell 1chsh -s /bin/ksh 参考： https://yq.aliyun.com/articles/69520?utm_content=m_10360 b16a95d8d40f6e6dee9ac2b3ed7aec1dcfe89983]]></content>
      <categories>
        <category>linux命令行</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conky配置Harmattan主题]]></title>
    <url>%2F2018%2F10%2F04%2Fconky%E9%85%8D%E7%BD%AEHarmattan%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[下载Harmattan主题 git clone https://github.com/zagortenay333/Harmattan.git 安装conky 1$ sudo apt install conky-all lm-sensors 上https://openweathermap.org/注册用户取得api和location id 执行preview按提示选择一个喜欢的主题,安装,会提示填入api和location id 1$./preview 网卡，字体问题 1$ vim ~/.conkyrc 默认Droid Sans我的ubuntu没有，换了一个字体就正常了网卡我的叫eno1，复制一份配置文件中的eth0的，改成自己的网卡名即可]]></content>
      <categories>
        <category>linux桌面</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>conky</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.js笔记]]></title>
    <url>%2F2018%2F10%2F02%2Fvue-js%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[vue学习笔记 《vue.js实战》随书源码 https://github.com/icarusion/vue-book《vue.js实战》随书源码网友整理完整版本 https://github.com/zyf711/vue-combat-book vue实例参数elel用于指定一个页面中已存在的DOM元素来挂载vue实例 vue生命周期 created 实例创建完成后调用，此阶段完成数据观测，但未挂载，$el不可用 mounted el挂载到实例上后调用，一般业务逻辑开始地方 beforeDestroy 实例销毁之前调用，解绑一些使用addEventListener监听事件等。 v-html 输出html标签v-bind动态更新HTML元素上的属性,比如id,class 对象语法 1234567&lt;div :class="&#123; 'active': isActive &#125;"&gt;&lt;/div&gt;// isActive为true时候得到active&lt;div class="static" :class="&#123; 'active: isActive, 'error': isError&#125;"&gt;&lt;/div&gt;// :class可以与普通class共存// :class表达式过长，逻辑比较复杂时候，可以绑定计算属性 数组语法 12&lt;div :class="[activeCls, errorCls]"&gt;&lt;/div&gt;// 可以给:class绑定一个数组 v-on绑定事件监听 v-model用于表单上双向绑定数据。修饰符：.lazy在失焦或者回车时候更新，.number输入转成数字，.trim自动过滤首尾空格 v-pre1&lt;span v-pre&gt; &#123;&#123;直接显示出来&#125;&#125; &lt;/span&gt; 防止被编译 {{}}除了简单绑定属性值外，还可以使用简单运算，三元运算，但是不能使用控制流vue实例computed计算属性在实例vue内的compu+-ted内写入。与methods区别为computed带缓存 组件12345678910111213141516171819Vue.component('my-component', &#123; props: ['xxxx'], // 单向传递数据，父组件传递给子组件，可以是字符串数组，对象，v-bind绑定 template: '&lt;div&gt; my component &lt;/div&gt;', data: xxx, methods: &#123; fun_name1: function() &#123; this.$emit('') //子组件向父组件传递参数,或者使用v-model &#125;, fun_name2: function() &#123; this.$dispatch() // 非父子组件通信，下级向上级 this.$broadcast() // 非父子组件通信，上级向下级 &#125;, fun_name3: function() &#123; //不推荐使用 this.$parent.xxx = '' // 直接访问该组件的父实例或组件 this.$children.xxx = ''// 父组件直接访问所有子组件 &#125; &#125;&#125;) slot123单个slot &lt;slot&gt; &lt;/slot&gt;具名slot &lt;div slot=“xxx"&gt; &lt;/div&gt;访问slot $slots 自定义指令123456789vue.directive(&apos;xxxx&apos;, &#123;&#125;) // 全局注册var app = new Vue(&#123; el: &apos;#app&apos;, directives: &#123; xxxx: &#123; //局部注册 &#125; &#125;&#125;)]]></content>
      <categories>
        <category>vue.js</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>vue.js</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo笔记]]></title>
    <url>%2F2018%2F10%2F01%2Fhexo%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ubuntu 16.04 环境问题12ERROR Local hexo not found in ~/blog:ERROR Try running: &apos;npm install hexo --save&apos; 无论如何安装，运行hexo都会报错，最后更新nodejs，不使用源里面的解决了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongodb笔记]]></title>
    <url>%2F2018%2F10%2F01%2Fmongodb%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[https://blog.csdn.net/five3/article/details/54632932?utm_source=copy 2.6.x版本的设置 mongodb用户权限设置123#vim /etc/mongodb.conf去掉auth=true注释重启服务 设置root,用户密码12345678&gt;use admin&gt;db.createUser(&#123;user:&apos;root&apos;,pwd:&apos;root&apos;,roles:[&#123;role:&quot;dbAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;,&#123;role:&quot;userAdminAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;)退出后使用root账户登录#mongo -u root -p root&gt;use youdb&gt;db.createUser(&#123;user:&apos;user&apos;,pwd:&apos;user&apos;,roles:[&#123;role:&quot;read&quot;,db:&quot;youdb&quot;&#125;,&#123;role:&quot;readWrite&quot;,db:&quot;youdb&quot;&#125;]&#125;) 设置成功后退出登录测试#mongo -u user -p user --authenticationDatabase youdb 3.4.x版本的设置待补充 4.0.x版本的设置 不使用认证权限启动 创建用户管理员 12345678&gt;use admin&gt;db.createUser( &#123; user: &quot;myUserAdmin&quot;, pwd: &quot;abc123&quot;, roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125;, &quot;readWriteAnyDatabase&quot; ] &#125;) 开启认证权限，用–auth参数启动，或者配置文件开启 12security: authorization: enabled 用刚刚配置的用户管理员登陆 1mongo --port 27017 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot; 创建用户 123456789use testdb.createUser( &#123; user: &quot;myTester&quot;, pwd: &quot;xyz123&quot;, roles: [ &#123; role: &quot;readWrite&quot;, db: &quot;test&quot; &#125;, &#123; role: &quot;read&quot;, db: &quot;reporting&quot; &#125; ] &#125;) 导出csv http://yangcongchufang.com/mongo-export-csv.html12345# 直接从某个表导出期望字段，生成CSVmongoexport --host 10.8.8.111 --db sampleData --collection eventV4 --csv --out events.csv --fields &apos;_id,something&apos;# 增加一个检索filter后导出CSVmongoexport --host 10.8.8.111 --db sampleData --collection eventV4 --queryFile ./range.json --csv --out events.csv --fields &apos;_id,something&apos;]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔性CSS3 + HTML5动画特效]]></title>
    <url>%2F2018%2F09%2F27%2Fhtml5css_movie%2F</url>
    <content type="text"><![CDATA[https://codepen.io/ge1doot/pen/LkdOwj { class Robot { constructor(color, light, size, x, y, struct) { this.x = x; this.points = []; this.links = []; this.frame = 0; this.dir = 1; this.size = size; this.color = Math.round(color); this.light = light; // ---- create points ---- for (const p of struct.points) { this.points.push(new Robot.Point(size * p.x + x, size * p.y + y, p.f)); } // ---- create links ---- for (const link of struct.links) { const p0 = this.points[link.p0]; const p1 = this.points[link.p1]; const dx = p0.x - p1.x; const dy = p0.y - p1.y; this.links.push( new Robot.Link( this, p0, p1, Math.sqrt(dx * dx + dy * dy), link.size * size / 3, link.lum, link.force, link.disk ) ); } } update() { if (++this.frame % 20 === 0) this.dir = -this.dir; if ( dancerDrag && this === dancerDrag && this.size < 16 && this.frame > 600 ) { dancerDrag = null; dancers.push( new Robot( this.color + 90, this.light * 1.25, this.size * 2, pointer.x, pointer.y - 100 * this.size * 2, struct ) ); dancers.sort(function(d0, d1) { return d0.size - d1.size; }); } // ---- update links ---- for (const link of this.links) link.update(); // ---- update points ---- for (const point of this.points) point.update(this); // ---- ground ---- for (const link of this.links) { const p1 = link.p1; if (p1.y > canvas.height * ground - link.size * 0.5) { p1.y = canvas.height * ground - link.size * 0.5; p1.x -= p1.vx; p1.vx = 0; p1.vy = 0; } } // ---- screen limits ---- if (this.points[1].x < 0) this.points[1].x = 0; else if (this.points[1].x > canvas.width) this.points[1].x = canvas.width; } } Robot.Link = class Link { constructor(parent, p0, p1, dist, size, light, force, disk) { this.p0 = p0; this.p1 = p1; this.distance = dist; this.size = size; this.light = light || 1.0; this.force = force || 0.5; this.color = `hsl(${parent.color}, 30%, ${parent.light * this.light}%)`; this.disk = disk; } update() { const p0 = this.p0; const p1 = this.p1; const dx = p1.x - p0.x; const dy = p1.y - p0.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 0.0) { const tw = p0.w + p1.w; const r1 = p1.w / tw; const r0 = p0.w / tw; const dz = (this.distance - dist) * this.force; const sx = dx / dist * dz; const sy = dy / dist * dz; p1.x += sx * r0; p1.y += sy * r0; p0.x -= sx * r1; p0.y -= sy * r1; } // ---- draw link ---- if (this.size) { const w = this.size; const a = Math.atan2(dy, dx); const c = Math.cos(a); const s = Math.sin(a); if (this.disk) { ctx.setTransform(c, s, -s, c, p1.x + w * 0.25, p1.y + w * 0.25); ctx.beginPath(); ctx.arc(0, 0, w * 0.5, 0, 2 * Math.PI); ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; ctx.fill(); } else { ctx.setTransform(c, s, -s, c, p0.x + w * 0.25, p0.y + w * 0.25); ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = w; ctx.beginPath(); ctx.strokeStyle = "rgba(0, 0, 0, 0.5)"; ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke(); } if (this.disk) { ctx.setTransform(c, s, -s, c, p1.x, p1.y); ctx.beginPath(); ctx.arc(0, 0, w * 0.5, 0, 2 * Math.PI); ctx.fillStyle = this.color; ctx.fill(); ctx.fillStyle = "#000"; ctx.fillRect(-w * 0.1, -w * 0.1, w * 0.2, w * 0.2); } else { ctx.setTransform(c, s, -s, c, p0.x, p0.y); ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = w; ctx.beginPath(); ctx.strokeStyle = this.color; ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-w * 0.1, -w * 0.1, w * 0.2, w * 0.2); ctx.fillRect(dist - w * 0.1, -w * 0.1, w * 0.2, w * 0.2); } } } }; Robot.Point = class Point { constructor(x, y, fn, w) { this.x = x; this.y = y; this.w = w || 0.5; this.fn = fn || null; this.px = x; this.py = y; this.vx = 0.0; this.vy = 0.0; } update (robot) { // ---- dragging ---- if (robot === dancerDrag && this === pointDrag) { this.x += (pointer.x - this.x) * 0.1; this.y += (pointer.y - this.y) * 0.1; } // ---- dance ---- if (robot !== dancerDrag) { this.fn && this.fn(16 * Math.sqrt(robot.size), robot.dir); } // ---- verlet integration ---- this.vx = this.x - this.px; this.vy = this.y - this.py; this.px = this.x; this.py = this.y; this.vx *= 0.995; this.vy *= 0.995; this.x += this.vx; this.y += this.vy + 0.01; } }; // ---- set canvas ---- const canvas = { init() { this.elem = document.querySelector("canvas"); this.resize(); window.addEventListener("resize", () => this.resize(), false); return this.elem.getContext("2d"); }, resize() { this.width = this.elem.width = this.elem.offsetWidth; this.height = this.elem.height = this.elem.offsetHeight; ground = this.height > 500 ? 0.85 : 1.0; for (let i = 0; i < dancers.length; i++) { dancers[i].x = (i + 2) * canvas.width / 9; } } }; // ---- set pointer ---- const pointer = { init(canvas) { this.x = 0; this.y = 0; window.addEventListener("mousemove", e => this.move(e), false); canvas.elem.addEventListener("touchmove", e => this.move(e), false); window.addEventListener("mousedown", e => this.down(e), false); window.addEventListener("touchstart", e => this.down(e), false); window.addEventListener("mouseup", e => this.up(e), false); window.addEventListener("touchend", e => this.up(e), false); }, down(e) { this.move(e); for (const dancer of dancers) { for (const point of dancer.points) { console.log("pointer:" + pointer.x) console.log("point:" + point.x) const dx = pointer.x - point.x; const dy = pointer.y - point.y; const d = Math.sqrt(dx * dx + dy * dy); if (d < 60) { dancerDrag = dancer; pointDrag = point; dancer.frame = 0; } } } }, up(e) { dancerDrag = null; }, move(e) { let touchMode = e.targetTouches, pointer; if (touchMode) { e.preventDefault(); pointer = touchMode[0]; } else pointer = e; this.x = pointer.clientX; this.y = pointer.clientY; } }; // ---- init ---- const dancers = []; let ground = 1.0; const ctx = canvas.init(); pointer.init(canvas); let dancerDrag = null; let pointDrag = null; // ---- dance ---- const dance = () => { ctx.save(); for (let i = 0; i < dancers.length; i++) { const d0 = dancers[i]; d0.update(); // separation behavior for (let j = i + 1; j < dancers.length; j++) { const d1 = dancers[j]; const minDist = Math.abs(d0.x - d1.x); const actDist = Math.abs(d0.points[2].x - d1.points[2].x); if (actDist < minDist * 0.8) { const d = minDist - actDist; if (d0.points[2].x < d1.points[2].x) { d0.points[2].x -= d * 0.001; d1.points[2].x += d * 0.001; } else { d0.points[2].x += d * 0.001; d1.points[2].x -= d * 0.001; } } } } ctx.restore(); } // ---- main loop ---- const run = () => { requestAnimationFrame(run); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, canvas.height * 0.15); ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15); dance(); }; // ---- robot structure ---- const struct = { points: [ { x: 0, y: -4, f(s, d) { this.y -= 0.01 * s; } }, { x: 0, y: -16, f(s, d) { this.y -= 0.02 * s * d; } }, { x: 0, y: 12, f(s, d) { this.y += 0.02 * s * d; } }, { x: -12, y: 0 }, { x: 12, y: 0 }, { x: -3, y: 34, f(s, d) { if (d > 0) { this.x += 0.01 * s; this.y -= 0.015 * s; } else { this.y += 0.02 * s; } } }, { x: 3, y: 34, f(s, d) { if (d > 0) { this.y += 0.02 * s; } else { this.x -= 0.01 * s; this.y -= 0.015 * s; } } }, { x: -28, y: 0, f(s, d) { this.x += this.vx * 0.025; this.y -= 0.001 * s; } }, { x: 28, y: 0, f(s, d) { this.x += this.vx * 0.025; this.y -= 0.001 * s; } }, { x: -3, y: 64, f(s, d) { this.y += 0.015 * s; if (d > 0) { this.y -= 0.01 * s; } else { this.y += 0.05 * s; } } }, { x: 3, y: 64, f(s, d) { this.y += 0.015 * s; if (d > 0) { this.y += 0.05 * s; } else { this.y -= 0.01 * s; } } } ], links: [ { p0: 3, p1: 7, size: 12, lum: 0.5 }, { p0: 1, p1: 3, size: 24, lum: 0.5 }, { p0: 1, p1: 0, size: 60, lum: 0.5, disk: 1 }, { p0: 5, p1: 9, size: 16, lum: 0.5 }, { p0: 2, p1: 5, size: 32, lum: 0.5 }, { p0: 1, p1: 2, size: 50, lum: 1 }, { p0: 6, p1: 10, size: 16, lum: 1.5 }, { p0: 2, p1: 6, size: 32, lum: 1.5 }, { p0: 4, p1: 8, size: 12, lum: 1.5 }, { p0: 1, p1: 4, size: 24, lum: 1.5 } ] }; // ---- instanciate robots ---- for (let i = 0; i < 4; i++) { dancers.push( new Robot( i * 360 / 7, 80, 4, (i + 2) * canvas.width / 9, canvas.height * ground - 300, struct ) ); } // ---- warm up ---- run(); } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821&lt;canvas style="width: 100%; height: 500px; background: #000; cursor: pointer;"&gt;&lt;/canvas&gt;&lt;script&gt;&#123; class Robot &#123; constructor(color, light, size, x, y, struct) &#123; this.x = x; this.points = []; this.links = []; this.frame = 0; this.dir = 1; this.size = size; this.color = Math.round(color); this.light = light; // ---- create points ---- for (const p of struct.points) &#123; this.points.push(new Robot.Point(size * p.x + x, size * p.y + y, p.f)); &#125; // ---- create links ---- for (const link of struct.links) &#123; const p0 = this.points[link.p0]; const p1 = this.points[link.p1]; const dx = p0.x - p1.x; const dy = p0.y - p1.y; this.links.push( new Robot.Link( this, p0, p1, Math.sqrt(dx * dx + dy * dy), link.size * size / 3, link.lum, link.force, link.disk ) ); &#125; &#125; update() &#123; if (++this.frame % 20 === 0) this.dir = -this.dir; if ( dancerDrag &amp;&amp; this === dancerDrag &amp;&amp; this.size &lt; 16 &amp;&amp; this.frame &gt; 600 ) &#123; dancerDrag = null; dancers.push( new Robot( this.color + 90, this.light * 1.25, this.size * 2, pointer.x, pointer.y - 100 * this.size * 2, struct ) ); dancers.sort(function(d0, d1) &#123; return d0.size - d1.size; &#125;); &#125; // ---- update links ---- for (const link of this.links) link.update(); // ---- update points ---- for (const point of this.points) point.update(this); // ---- ground ---- for (const link of this.links) &#123; const p1 = link.p1; if (p1.y &gt; canvas.height * ground - link.size * 0.5) &#123; p1.y = canvas.height * ground - link.size * 0.5; p1.x -= p1.vx; p1.vx = 0; p1.vy = 0; &#125; &#125; // ---- screen limits ---- if (this.points[1].x &lt; 0) this.points[1].x = 0; else if (this.points[1].x &gt; canvas.width) this.points[1].x = canvas.width; &#125; &#125; Robot.Link = class Link &#123; constructor(parent, p0, p1, dist, size, light, force, disk) &#123; this.p0 = p0; this.p1 = p1; this.distance = dist; this.size = size; this.light = light || 1.0; this.force = force || 0.5; this.color = `hsl($&#123;parent.color&#125;, 30%, $&#123;parent.light * this.light&#125;%)`; this.disk = disk; &#125; update() &#123; const p0 = this.p0; const p1 = this.p1; const dx = p1.x - p0.x; const dy = p1.y - p0.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist &gt; 0.0) &#123; const tw = p0.w + p1.w; const r1 = p1.w / tw; const r0 = p0.w / tw; const dz = (this.distance - dist) * this.force; const sx = dx / dist * dz; const sy = dy / dist * dz; p1.x += sx * r0; p1.y += sy * r0; p0.x -= sx * r1; p0.y -= sy * r1; &#125; // ---- draw link ---- if (this.size) &#123; const w = this.size; const a = Math.atan2(dy, dx); const c = Math.cos(a); const s = Math.sin(a); if (this.disk) &#123; ctx.setTransform(c, s, -s, c, p1.x + w * 0.25, p1.y + w * 0.25); ctx.beginPath(); ctx.arc(0, 0, w * 0.5, 0, 2 * Math.PI); ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; ctx.fill(); &#125; else &#123; ctx.setTransform(c, s, -s, c, p0.x + w * 0.25, p0.y + w * 0.25); ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = w; ctx.beginPath(); ctx.strokeStyle = "rgba(0, 0, 0, 0.5)"; ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke(); &#125; if (this.disk) &#123; ctx.setTransform(c, s, -s, c, p1.x, p1.y); ctx.beginPath(); ctx.arc(0, 0, w * 0.5, 0, 2 * Math.PI); ctx.fillStyle = this.color; ctx.fill(); ctx.fillStyle = "#000"; ctx.fillRect(-w * 0.1, -w * 0.1, w * 0.2, w * 0.2); &#125; else &#123; ctx.setTransform(c, s, -s, c, p0.x, p0.y); ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = w; ctx.beginPath(); ctx.strokeStyle = this.color; ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-w * 0.1, -w * 0.1, w * 0.2, w * 0.2); ctx.fillRect(dist - w * 0.1, -w * 0.1, w * 0.2, w * 0.2); &#125; &#125; &#125; &#125;; Robot.Point = class Point &#123; constructor(x, y, fn, w) &#123; this.x = x; this.y = y; this.w = w || 0.5; this.fn = fn || null; this.px = x; this.py = y; this.vx = 0.0; this.vy = 0.0; &#125; update (robot) &#123; // ---- dragging ---- if (robot === dancerDrag &amp;&amp; this === pointDrag) &#123; this.x += (pointer.x - this.x) * 0.1; this.y += (pointer.y - this.y) * 0.1; &#125; // ---- dance ---- if (robot !== dancerDrag) &#123; this.fn &amp;&amp; this.fn(16 * Math.sqrt(robot.size), robot.dir); &#125; // ---- verlet integration ---- this.vx = this.x - this.px; this.vy = this.y - this.py; this.px = this.x; this.py = this.y; this.vx *= 0.995; this.vy *= 0.995; this.x += this.vx; this.y += this.vy + 0.01; &#125; &#125;; // ---- set canvas ---- const canvas = &#123; init() &#123; this.elem = document.querySelector("canvas"); this.resize(); window.addEventListener("resize", () =&gt; this.resize(), false); return this.elem.getContext("2d"); &#125;, resize() &#123; this.width = this.elem.width = this.elem.offsetWidth; this.height = this.elem.height = this.elem.offsetHeight; ground = this.height &gt; 500 ? 0.85 : 1.0; for (let i = 0; i &lt; dancers.length; i++) &#123; dancers[i].x = (i + 2) * canvas.width / 9; &#125; &#125; &#125;; // ---- set pointer ---- const pointer = &#123; init(canvas) &#123; this.x = 0; this.y = 0; window.addEventListener("mousemove", e =&gt; this.move(e), false); canvas.elem.addEventListener("touchmove", e =&gt; this.move(e), false); window.addEventListener("mousedown", e =&gt; this.down(e), false); window.addEventListener("touchstart", e =&gt; this.down(e), false); window.addEventListener("mouseup", e =&gt; this.up(e), false); window.addEventListener("touchend", e =&gt; this.up(e), false); &#125;, down(e) &#123; this.move(e); for (const dancer of dancers) &#123; for (const point of dancer.points) &#123; const dx = pointer.x - point.x; const dy = pointer.y - point.y; const d = Math.sqrt(dx * dx + dy * dy); if (d &lt; 60) &#123; dancerDrag = dancer; pointDrag = point; dancer.frame = 0; &#125; &#125; &#125; &#125;, up(e) &#123; dancerDrag = null; &#125;, move(e) &#123; let touchMode = e.targetTouches, pointer; if (touchMode) &#123; e.preventDefault(); pointer = touchMode[0]; &#125; else pointer = e; this.x = pointer.clientX; this.y = pointer.clientY; &#125; &#125;; // ---- init ---- const dancers = []; let ground = 1.0; const ctx = canvas.init(); pointer.init(canvas); let dancerDrag = null; let pointDrag = null; // ---- dance ---- const dance = () =&gt; &#123; ctx.save(); for (let i = 0; i &lt; dancers.length; i++) &#123; const d0 = dancers[i]; d0.update(); // separation behavior for (let j = i + 1; j &lt; dancers.length; j++) &#123; const d1 = dancers[j]; const minDist = Math.abs(d0.x - d1.x); const actDist = Math.abs(d0.points[2].x - d1.points[2].x); if (actDist &lt; minDist * 0.8) &#123; const d = minDist - actDist; if (d0.points[2].x &lt; d1.points[2].x) &#123; d0.points[2].x -= d * 0.001; d1.points[2].x += d * 0.001; &#125; else &#123; d0.points[2].x += d * 0.001; d1.points[2].x -= d * 0.001; &#125; &#125; &#125; &#125; ctx.restore(); &#125; // ---- main loop ---- const run = () =&gt; &#123; requestAnimationFrame(run); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, canvas.height * 0.15); ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15); dance(); &#125;; // ---- robot structure ---- const struct = &#123; points: [ &#123; x: 0, y: -4, f(s, d) &#123; this.y -= 0.01 * s; &#125; &#125;, &#123; x: 0, y: -16, f(s, d) &#123; this.y -= 0.02 * s * d; &#125; &#125;, &#123; x: 0, y: 12, f(s, d) &#123; this.y += 0.02 * s * d; &#125; &#125;, &#123; x: -12, y: 0 &#125;, &#123; x: 12, y: 0 &#125;, &#123; x: -3, y: 34, f(s, d) &#123; if (d &gt; 0) &#123; this.x += 0.01 * s; this.y -= 0.015 * s; &#125; else &#123; this.y += 0.02 * s; &#125; &#125; &#125;, &#123; x: 3, y: 34, f(s, d) &#123; if (d &gt; 0) &#123; this.y += 0.02 * s; &#125; else &#123; this.x -= 0.01 * s; this.y -= 0.015 * s; &#125; &#125; &#125;, &#123; x: -28, y: 0, f(s, d) &#123; this.x += this.vx * 0.025; this.y -= 0.001 * s; &#125; &#125;, &#123; x: 28, y: 0, f(s, d) &#123; this.x += this.vx * 0.025; this.y -= 0.001 * s; &#125; &#125;, &#123; x: -3, y: 64, f(s, d) &#123; this.y += 0.015 * s; if (d &gt; 0) &#123; this.y -= 0.01 * s; &#125; else &#123; this.y += 0.05 * s; &#125; &#125; &#125;, &#123; x: 3, y: 64, f(s, d) &#123; this.y += 0.015 * s; if (d &gt; 0) &#123; this.y += 0.05 * s; &#125; else &#123; this.y -= 0.01 * s; &#125; &#125; &#125; ], links: [ &#123; p0: 3, p1: 7, size: 12, lum: 0.5 &#125;, &#123; p0: 1, p1: 3, size: 24, lum: 0.5 &#125;, &#123; p0: 1, p1: 0, size: 60, lum: 0.5, disk: 1 &#125;, &#123; p0: 5, p1: 9, size: 16, lum: 0.5 &#125;, &#123; p0: 2, p1: 5, size: 32, lum: 0.5 &#125;, &#123; p0: 1, p1: 2, size: 50, lum: 1 &#125;, &#123; p0: 6, p1: 10, size: 16, lum: 1.5 &#125;, &#123; p0: 2, p1: 6, size: 32, lum: 1.5 &#125;, &#123; p0: 4, p1: 8, size: 12, lum: 1.5 &#125;, &#123; p0: 1, p1: 4, size: 24, lum: 1.5 &#125; ] &#125;; // ---- instanciate robots ---- for (let i = 0; i &lt; 4; i++) &#123; dancers.push( new Robot( i * 360 / 7, 80, 4, (i + 2) * canvas.width / 9, canvas.height * ground - 300, struct ) ); &#125; // ---- warm up ---- run();&#125;&lt;/script&gt;&lt;canvas style="width: 100%; height: 500px; background: #000; cursor: pointer;"&gt;&lt;/canvas&gt;&lt;script&gt;&#123; class Robot &#123; constructor(color, light, size, x, y, struct) &#123; this.x = x; this.points = []; this.links = []; this.frame = 0; this.dir = 1; this.size = size; this.color = Math.round(color); this.light = light; // ---- create points ---- for (const p of struct.points) &#123; this.points.push(new Robot.Point(size * p.x + x, size * p.y + y, p.f)); &#125; // ---- create links ---- for (const link of struct.links) &#123; const p0 = this.points[link.p0]; const p1 = this.points[link.p1]; const dx = p0.x - p1.x; const dy = p0.y - p1.y; this.links.push( new Robot.Link( this, p0, p1, Math.sqrt(dx * dx + dy * dy), link.size * size / 3, link.lum, link.force, link.disk ) ); &#125; &#125; update() &#123; if (++this.frame % 20 === 0) this.dir = -this.dir; if ( dancerDrag &amp;&amp; this === dancerDrag &amp;&amp; this.size &lt; 16 &amp;&amp; this.frame &gt; 600 ) &#123; dancerDrag = null; dancers.push( new Robot( this.color + 90, this.light * 1.25, this.size * 2, pointer.x, pointer.y - 100 * this.size * 2, struct ) ); dancers.sort(function(d0, d1) &#123; return d0.size - d1.size; &#125;); &#125; // ---- update links ---- for (const link of this.links) link.update(); // ---- update points ---- for (const point of this.points) point.update(this); // ---- ground ---- for (const link of this.links) &#123; const p1 = link.p1; if (p1.y &gt; canvas.height * ground - link.size * 0.5) &#123; p1.y = canvas.height * ground - link.size * 0.5; p1.x -= p1.vx; p1.vx = 0; p1.vy = 0; &#125; &#125; // ---- screen limits ---- if (this.points[1].x &lt; 0) this.points[1].x = 0; else if (this.points[1].x &gt; canvas.width) this.points[1].x = canvas.width; &#125; &#125; Robot.Link = class Link &#123; constructor(parent, p0, p1, dist, size, light, force, disk) &#123; this.p0 = p0; this.p1 = p1; this.distance = dist; this.size = size; this.light = light || 1.0; this.force = force || 0.5; this.color = `hsl($&#123;parent.color&#125;, 30%, $&#123;parent.light * this.light&#125;%)`; this.disk = disk; &#125; update() &#123; const p0 = this.p0; const p1 = this.p1; const dx = p1.x - p0.x; const dy = p1.y - p0.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist &gt; 0.0) &#123; const tw = p0.w + p1.w; const r1 = p1.w / tw; const r0 = p0.w / tw; const dz = (this.distance - dist) * this.force; const sx = dx / dist * dz; const sy = dy / dist * dz; p1.x += sx * r0; p1.y += sy * r0; p0.x -= sx * r1; p0.y -= sy * r1; &#125; // ---- draw link ---- if (this.size) &#123; const w = this.size; const a = Math.atan2(dy, dx); const c = Math.cos(a); const s = Math.sin(a); if (this.disk) &#123; ctx.setTransform(c, s, -s, c, p1.x + w * 0.25, p1.y + w * 0.25); ctx.beginPath(); ctx.arc(0, 0, w * 0.5, 0, 2 * Math.PI); ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; ctx.fill(); &#125; else &#123; ctx.setTransform(c, s, -s, c, p0.x + w * 0.25, p0.y + w * 0.25); ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = w; ctx.beginPath(); ctx.strokeStyle = "rgba(0, 0, 0, 0.5)"; ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke(); &#125; if (this.disk) &#123; ctx.setTransform(c, s, -s, c, p1.x, p1.y); ctx.beginPath(); ctx.arc(0, 0, w * 0.5, 0, 2 * Math.PI); ctx.fillStyle = this.color; ctx.fill(); ctx.fillStyle = "#000"; ctx.fillRect(-w * 0.1, -w * 0.1, w * 0.2, w * 0.2); &#125; else &#123; ctx.setTransform(c, s, -s, c, p0.x, p0.y); ctx.beginPath(); ctx.lineCap = "round"; ctx.lineWidth = w; ctx.beginPath(); ctx.strokeStyle = this.color; ctx.moveTo(0, 0); ctx.lineTo(dist, 0); ctx.stroke(); ctx.fillStyle = "#000"; ctx.fillRect(-w * 0.1, -w * 0.1, w * 0.2, w * 0.2); ctx.fillRect(dist - w * 0.1, -w * 0.1, w * 0.2, w * 0.2); &#125; &#125; &#125; &#125;; Robot.Point = class Point &#123; constructor(x, y, fn, w) &#123; this.x = x; this.y = y; this.w = w || 0.5; this.fn = fn || null; this.px = x; this.py = y; this.vx = 0.0; this.vy = 0.0; &#125; update (robot) &#123; // ---- dragging ---- if (robot === dancerDrag &amp;&amp; this === pointDrag) &#123; this.x += (pointer.x - this.x) * 0.1; this.y += (pointer.y - this.y) * 0.1; &#125; // ---- dance ---- if (robot !== dancerDrag) &#123; this.fn &amp;&amp; this.fn(16 * Math.sqrt(robot.size), robot.dir); &#125; // ---- verlet integration ---- this.vx = this.x - this.px; this.vy = this.y - this.py; this.px = this.x; this.py = this.y; this.vx *= 0.995; this.vy *= 0.995; this.x += this.vx; this.y += this.vy + 0.01; &#125; &#125;; // ---- set canvas ---- const canvas = &#123; init() &#123; this.elem = document.querySelector("canvas"); this.resize(); window.addEventListener("resize", () =&gt; this.resize(), false); return this.elem.getContext("2d"); &#125;, resize() &#123; this.width = this.elem.width = this.elem.offsetWidth; this.height = this.elem.height = this.elem.offsetHeight; ground = this.height &gt; 500 ? 0.85 : 1.0; for (let i = 0; i &lt; dancers.length; i++) &#123; dancers[i].x = (i + 2) * canvas.width / 9; &#125; &#125; &#125;; // ---- set pointer ---- const pointer = &#123; init(canvas) &#123; this.x = 0; this.y = 0; window.addEventListener("mousemove", e =&gt; this.move(e), false); canvas.elem.addEventListener("touchmove", e =&gt; this.move(e), false); window.addEventListener("mousedown", e =&gt; this.down(e), false); window.addEventListener("touchstart", e =&gt; this.down(e), false); window.addEventListener("mouseup", e =&gt; this.up(e), false); window.addEventListener("touchend", e =&gt; this.up(e), false); &#125;, down(e) &#123; this.move(e); for (const dancer of dancers) &#123; for (const point of dancer.points) &#123; const dx = pointer.x - point.x; const dy = pointer.y - point.y; const d = Math.sqrt(dx * dx + dy * dy); if (d &lt; 60) &#123; dancerDrag = dancer; pointDrag = point; dancer.frame = 0; &#125; &#125; &#125; &#125;, up(e) &#123; dancerDrag = null; &#125;, move(e) &#123; let touchMode = e.targetTouches, pointer; if (touchMode) &#123; e.preventDefault(); pointer = touchMode[0]; &#125; else pointer = e; this.x = pointer.clientX; this.y = pointer.clientY; &#125; &#125;; // ---- init ---- const dancers = []; let ground = 1.0; const ctx = canvas.init(); pointer.init(canvas); let dancerDrag = null; let pointDrag = null; // ---- dance ---- const dance = () =&gt; &#123; ctx.save(); for (let i = 0; i &lt; dancers.length; i++) &#123; const d0 = dancers[i]; d0.update(); // separation behavior for (let j = i + 1; j &lt; dancers.length; j++) &#123; const d1 = dancers[j]; const minDist = Math.abs(d0.x - d1.x); const actDist = Math.abs(d0.points[2].x - d1.points[2].x); if (actDist &lt; minDist * 0.8) &#123; const d = minDist - actDist; if (d0.points[2].x &lt; d1.points[2].x) &#123; d0.points[2].x -= d * 0.001; d1.points[2].x += d * 0.001; &#125; else &#123; d0.points[2].x += d * 0.001; d1.points[2].x -= d * 0.001; &#125; &#125; &#125; &#125; ctx.restore(); &#125; // ---- main loop ---- const run = () =&gt; &#123; requestAnimationFrame(run); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "#222"; ctx.fillRect(0, 0, canvas.width, canvas.height * 0.15); ctx.fillRect(0, canvas.height * 0.85, canvas.width, canvas.height * 0.15); dance(); &#125;; // ---- robot structure ---- const struct = &#123; points: [ &#123; x: 0, y: -4, f(s, d) &#123; this.y -= 0.01 * s; &#125; &#125;, &#123; x: 0, y: -16, f(s, d) &#123; this.y -= 0.02 * s * d; &#125; &#125;, &#123; x: 0, y: 12, f(s, d) &#123; this.y += 0.02 * s * d; &#125; &#125;, &#123; x: -12, y: 0 &#125;, &#123; x: 12, y: 0 &#125;, &#123; x: -3, y: 34, f(s, d) &#123; if (d &gt; 0) &#123; this.x += 0.01 * s; this.y -= 0.015 * s; &#125; else &#123; this.y += 0.02 * s; &#125; &#125; &#125;, &#123; x: 3, y: 34, f(s, d) &#123; if (d &gt; 0) &#123; this.y += 0.02 * s; &#125; else &#123; this.x -= 0.01 * s; this.y -= 0.015 * s; &#125; &#125; &#125;, &#123; x: -28, y: 0, f(s, d) &#123; this.x += this.vx * 0.025; this.y -= 0.001 * s; &#125; &#125;, &#123; x: 28, y: 0, f(s, d) &#123; this.x += this.vx * 0.025; this.y -= 0.001 * s; &#125; &#125;, &#123; x: -3, y: 64, f(s, d) &#123; this.y += 0.015 * s; if (d &gt; 0) &#123; this.y -= 0.01 * s; &#125; else &#123; this.y += 0.05 * s; &#125; &#125; &#125;, &#123; x: 3, y: 64, f(s, d) &#123; this.y += 0.015 * s; if (d &gt; 0) &#123; this.y += 0.05 * s; &#125; else &#123; this.y -= 0.01 * s; &#125; &#125; &#125; ], links: [ &#123; p0: 3, p1: 7, size: 12, lum: 0.5 &#125;, &#123; p0: 1, p1: 3, size: 24, lum: 0.5 &#125;, &#123; p0: 1, p1: 0, size: 60, lum: 0.5, disk: 1 &#125;, &#123; p0: 5, p1: 9, size: 16, lum: 0.5 &#125;, &#123; p0: 2, p1: 5, size: 32, lum: 0.5 &#125;, &#123; p0: 1, p1: 2, size: 50, lum: 1 &#125;, &#123; p0: 6, p1: 10, size: 16, lum: 1.5 &#125;, &#123; p0: 2, p1: 6, size: 32, lum: 1.5 &#125;, &#123; p0: 4, p1: 8, size: 12, lum: 1.5 &#125;, &#123; p0: 1, p1: 4, size: 24, lum: 1.5 &#125; ] &#125;; // ---- instanciate robots ---- for (let i = 0; i &lt; 4; i++) &#123; dancers.push( new Robot( i * 360 / 7, 80, 4, (i + 2) * canvas.width / 9, canvas.height * ground - 300, struct ) ); &#125; // ---- warm up ---- run();&#125;&lt;/script&gt;]]></content>
      <categories>
        <category>网摘</category>
      </categories>
      <tags>
        <tag>网摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git笔记]]></title>
    <url>%2F2018%2F09%2F23%2Fgit%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考教程：沉浸式学Git http://igit.linuxtoy.org/contents.html 设置编辑器1git config --global core.editor &quot;vim&quot; clone指定分支1git clone -b 分支名 http://xxxxxxx alisa别名12345678910$vim ~/.gitconfig[alisa] co = checkout ci = commit st = status br = branch hist = log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short type = cat-file -t dump = cat-file -p 保存密码 设置记住密码（默认15分钟）：git config –global credential.helper cache 如果想自己设置时间，可以这样做：git config credential.helper ‘cache –timeout=3600’这样就设置一个小时之后失效 长期存储密码：git config --global credential.helper store 增加远程地址的时候带上密码也是可以的。(推荐)http://yourname:password@git.oschina.net/name/project.git 退回本地未提交更改删除untracked的文件1$git clean -df 将tracked文件退回，不写hash则退回上一个版本1$git reset --hard &lt;hash&gt; 删除文件保留本地文件1$git rm -r --cached some-directory tag123456$ git tag -a &apos;v1.5&apos; -m &apos;注释&apos; //创建本地标签$ git push origin v1.5 //提交本地标签到远程$ git push origin --tags //提交所有本地标签到远程$ git tag -l //标签列表$ git tag -d v1.5 //删除本地标签$ git push origin --delete tag v1.5 //删除远程标签 下载子模块1git submodule update --init --recursive 删除子模块1234567git submodule deinit 模块名字# 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）git rm --cached 模块名字# 提交更改到代码库，可观察到&apos;.gitmodules&apos;内容发生变更git commit -am &quot;Remove a submodule.&quot; submodule用法12# 拉取子模块git submodule add https://github.com/cofess/hexo-theme-pure themes/pure fork后合并原作者更新12345678910111213git remote add upstream https://github.com/原作者地址echo &quot;获取远程源的更新。&quot;git fetch upstreamecho &quot;合并到本地库中。&quot;git merge upstream/masterecho &quot;提交到本地版本库中。&quot;git commit -a -m &quot;merged upstream.&quot;echo &quot;推送提交到自己的github库中。&quot;git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
